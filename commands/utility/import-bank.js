const {  SlashCommandBuilder,  ContainerBuilder,  MessageFlags,  ThreadAutoArchiveDuration} = require('discord.js');const CSV = require('csv-string')const {channelId, threadName} = require('../../config.json');module.exports = {  data: new SlashCommandBuilder()    .setName('importbank')    .setDescription('Import a bank string from Guild Bank List Creator Plus addon')    .addAttachmentOption((option) => option.setName('attachment').setDescription('The input to echo back').setRequired(true)),  async execute(client, interaction) {    await interaction.deferReply({ephemeral: true});    // Get CSV data    const attachment = interaction.options.getAttachment('attachment');    const csvData = await getAttachmentContents(attachment);    const itemGroups = {};    // Iterate over CSV records and prepare objects for each item, grouped by item group    CSV.forEach(csvData, ',', function (row, index) {      if (row.length !== 7) {        return;      }      const itemName = row[0];      const itemQuantity = row[1];      const itemLink = row[2];      const itemQuality = row[4];      let itemGroup = row[5];      const itemSlot = row[6];      const item = postProcessItem({        name: itemName,        quantity: itemQuantity,        link: itemLink,        quality: itemQuality,        slot: itemSlot,      });      itemGroup = overrideItemGroups(item, itemGroup);      if (!Object.hasOwn(itemGroups, itemGroup)) {        itemGroups[itemGroup] = [];      }      itemGroups[itemGroup].push(item);    });    // Prepare the thread (deleting any existing anyone, creating a new one)    const thread = await prepareThread(client);    // Sort item groups alphabetically, but with priority groups at the top    let itemGroupKeys = Object.keys(itemGroups);    itemGroupKeys.sort();    const priorityGroupNames = getPriorityGroupNames();    const priorityGroups = [];    const otherGroups = [];    itemGroupKeys.forEach(groupKey => {      let added = false;      priorityGroupNames.forEach(priorityGroupName => {        if (groupKey.includes(priorityGroupName)) {          priorityGroups.push(groupKey);          added = true;        }      });      if (!added) {        otherGroups.push(groupKey);      }    });    itemGroupKeys = priorityGroups.concat(otherGroups);    // Loop over items and send messages in batches, grouped by item group    const MAX_ITEMS_PER_MSG = 39;    const NEXT_MSG_ITEM_PADDING = 5;    let containerComponent = null;    for (let i = 0; i < itemGroupKeys.length; i++) {      const itemGroup = itemGroupKeys[i];      const itemsInGroup = itemGroups[itemGroup];      itemsInGroup.sort((a, b) => a.name.localeCompare(b.name));      if (containerComponent != null && (containerComponent.components.length + NEXT_MSG_ITEM_PADDING) >= MAX_ITEMS_PER_MSG) {        await sendContainerComponent(thread, containerComponent);        console.log('starting new msg container - ' + containerComponent.components.length);        containerComponent = null;      }      if (!containerComponent) {        containerComponent = createContainerComponent(itemGroup);      }      addItemGroupHeader(containerComponent, itemGroup);      for (let j = 0; j < itemsInGroup.length; j++) {        const item = itemsInGroup[j];        if (containerComponent.components.length >= MAX_ITEMS_PER_MSG) {          await sendContainerComponent(thread, containerComponent);          console.log('starting new msg container - ' + containerComponent.components.length);          containerComponent = createContainerComponent(itemGroup);          addItemGroupHeader(containerComponent, itemGroup + ' (Continued)');        }        containerComponent.addTextDisplayComponents((textDisplay) =>          textDisplay.setContent('[' + item.name + '](' + item.link + ') x' + item.quantity,),        )      }			afterGroupItemsAdded(itemGroup, itemsInGroup, thread, containerComponent);    }    console.log('Adding final msg container - ' + containerComponent.components.length);    await sendContainerComponent(thread, containerComponent);    await interaction.editReply({      content: `Import has been successfully processed`,    });  },};const getAttachmentContents = async (attachment) => {  const response = await fetch(attachment.attachment)  const data = await response.text()  return data.trim();};const prepareThread = async (client) => {  console.log('CHANNEL ID: ' + channelId);  const channel = await client.channels.fetch(channelId);  const existingThread = channel.threads.cache.find((x) => x.name === threadName);  if (existingThread) {    await existingThread.delete();  }  const currentTimestamp = Math.floor(Date.now() / 1000);  const thread = await channel.threads.create({    name: threadName,    autoArchiveDuration: ThreadAutoArchiveDuration.ThreeDays,    reason: 'New guild bank import',    message: {      content: 'Snapshot of the guild bank contents as of <t:' + currentTimestamp + '>',    },  });  await thread.pin({    reason: 'Keep at top!',  });  await thread.setLocked(true);  return thread;};const createContainerComponent = (itemGroup, isFirst) => {  return new ContainerBuilder()    .setAccentColor(0x0099ff);}const addItemGroupHeader = (component, itemGroup) => {  if (component.components.length > 2) {    component.addSeparatorComponents((separator) => separator);  }  component.addTextDisplayComponents((textDisplay) =>    textDisplay.setContent('**' + itemGroup + '**'),  );  component.addSeparatorComponents((separator) => separator);};const sendContainerComponent = async (thread, component) => {  await thread.send({    components: [component],    flags: MessageFlags.IsComponentsV2,  });};const postProcessItem = (item) => {  item.itemId = item.link.replace('https://classic.wowhead.com/item=', '');  //console.log('Extracted item ID ' + item.itemId + ' from ' + item.name);  switch (item.itemId) {    // Voodoo dolls    case "19818":      item.name = item.name + ' (Mage)';      break;    case "19813":      item.name = item.name + ' (Warrior)';      break;    case "19814":      item.name = item.name + ' (Rogue)';      break;    case "19815":      item.name = item.name + ' (Paladin)';      break;    case "19816":      item.name = item.name + ' (Hunter)';      break;    case "19817":      item.name = item.name + ' (Shaman)';      break;    case "19819":      item.name = item.name + ' (Warlock)';      break;    case "19820":      item.name = item.name + ' (Priest)';      break;    case "19821":      item.name = item.name + ' (Druid)';      break;  }  return item;}const getOverrideGroups = () => {  return [    {      "name": "Zul'Gurub - Bijous",      "masks": [        'Bijou',      ]    },    {      "name": "Zul'Gurub - Coin Set #1",      "masks": [        'Zulian Coin',        'Razzashi Coin',        'Hakkari Coin',      ],      "getMinMessagesLeft": (items) => {        return items.length + 1;      },    },    {      "name": "Zul'Gurub - Coin Set #2",      "masks": [        'Gurubashi Coin',        'Vilebranch Coin',        'Witherbark Coin',      ],      "getMinMessagesLeft": (items) => {        return items.length + 1;      },    },    {      "name": "Zul'Gurub - Coin Set #3",      "masks": [        'Sandfury Coin',        'Skullsplitter Coin',        'Bloodscalp Coin',      ],      "getMinMessagesLeft": (items) => {        return items.length + 1;      },    },    {      "name": "Zul'Gurub - Dolls",      "masks": [        'Voodoo Doll',      ]    },    {      "name": "Zul'Gurub - Trade Goods",      "masks": [        'Bloodvine',        'Primal Bat Leather',        'Primal Tiger Leather',        'Souldarite',      ]    },    {      "name": "Ahn'Qiraj - Idols",      "masks": [        'Idol',      ]    },    {      "name": "Ahn'Qiraj - Scarabs",      "masks": [        'Scarab',      ]    },    {      "name": "Ahn'Qiraj - Trade Goods",      "masks": [        'Large Obsidian Shard',        'Small Obsidian Shard',      ],    },    {      "name": "Ahn'Qiraj - Trade Goods",      "masks": [        'Large Obsidian Shard',        'Small Obsidian Shard',      ],    },    {      "name": "Onyxia",      "masks": [        'Scale of Onyxia',      ]    },    {      "name": "Molten Core",      "masks": [        'Fiery Core',        'Lava Core',        'Core Leather',      ]    },    {      "name": "Herbalism",      "masks": [        "Peacebloom",        "Silverleaf",        "Earthroot",        "Mageroyal",        "Briarthorn",        "Swiftthistle",        "Stranglekelp",        "Bruiseweed",        "Wild Steelbloom",        "Grave Moss",        "Kingsblood",        "Liferoot",        "Fadeleaf",        "Goldthorn",        "Khadgar's Whisker",        "Wintersbite",        "Firebloom",        "Purple Lotus",        "Wildvine",        "Arthas' Tears",        "Sungrass",        "Blindweed",        "Ghost Mushroom",        "Gromsblood",        "Golden Sansam",        "Dreamfoil",        "Mountain Silversage",        "Plaguebloom",        "Icecap",        "Black Lotus",      ]    },    {      "name": "Enchanting",      "masks": [        "Strange Dust",        "Soul Dust",        "Vision Dust",        "Dream Dust",        "Illusion Dust",        "Lesser Magic Essence",        "Greater Magic Essence",        "Lesser Astral Essence",        "Greater Astral Essence",        "Lesser Mystic Essence",        "Greater Mystic Essence",        "Lesser Nether Essence",        "Greater Nether Essence",        "Lesser Eternal Essence",        "Greater Eternal Essence",        "Small Glimmering Shard",        "Large Glimmering Shard",        "Small Glowing Shard",        "Large Glowing Shard",        "Small Radiant Shard",        "Large Radiant Shard",        "Small Brilliant Shard",        "Large Brilliant Shard",        "Nexus Crystal"      ]    },  ];}const overrideItemGroups = (item, itemGroup) => {  const overrides = getOverrideGroups();  for (let i = 0; i < overrides.length; i++) {    const groupDetails = overrides[i];    for (let j = 0; j < groupDetails.masks.length; j++) {      const mask = groupDetails.masks[j];      if (item.name.includes(mask)) {        return groupDetails.name;      }    }  }  const itemSlots = [    "Ammo",    "Head",    "Neck",    "Shoulder",    "Shirt",    "Chest",    "Chest",    "Waist",    "Legs",    "Feet",    "Wrist",    "Hands",    "Finger",    "Trinket",    "Back",    "One-Hand",    "Off Hand",    "Two-Hand",    "Main Hand",    "Off Hand",    "Held In Off-hand",    "Ranged",    "Thrown",    "Ranged",    "Relic",  ];  if (itemSlots.includes(item.slot)) {    return 'Equipment (' + item.quality + ')';  }  return itemGroup;};const getPriorityGroupNames = () => {  return [    "Ahn'Qiraj",    "Zul'Gurub",    "Onyxia",    "Molten Core",    "Book",  ];}const afterGroupItemsAdded = (itemGroup, items, thread, containerComponent) => {  switch (itemGroup) {    case "Zul'Gurub - Coin Set #1":    case "Zul'Gurub - Coin Set #2":    case "Zul'Gurub - Coin Set #3":      const minSets = Math.min(...items.map(item => item.quantity));      containerComponent.addTextDisplayComponents((textDisplay) =>        textDisplay.setContent('Sets Available: ' + minSets),      );      break;  }};